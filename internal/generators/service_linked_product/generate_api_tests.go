package main

import (
	. "github.com/dave/jennifer/jen"
	"github.com/fastly/go-fastly/v9/internal/generators"
)

func generate_api_tests(g *Generator) error {
	var err error

	f := NewFile(g.base.APITestPackage.Name)

	g.base.Header(f)

	f.Line()

	validateGetFunction(g, f)

	validateEnableFunction(g, f, g.base.FindDefinedTypeStruct(g.base.APIPackage, "EnableInput"))

	validateDisableFunction(g, f)

	if g.base.FindDefinedTypeStruct(g.base.APIPackage, "ConfigureInput") {
		validateGetConfigurationFunction(g, f)
		validateUpdateConfigurationFunction(g, f)
	}

	if err = f.Save("api_test.go"); err != nil {
		return err
	}

	return nil
}

type validateFunctionInput struct {
	f           *File
	method      string
	returnsBody bool
	needsInput  bool
	testCaseMap string
}

func validateFunction(g *Generator, i *validateFunctionInput) {
	parameter := Id("t").Op("*").Qual("testing", "T")

	var returnVals []Code

	if i.returnsBody {
		returnVals = []Code{Id("_"), Err()}
	} else {
		returnVals = []Code{Err()}
	}

	var body []Code
	var getResult Code
	var testResult Code
	var generateError Code

	if !i.needsInput {
		// generate a single test case which validates that
		// an empty 'serviceID' parameter produces an
		// 'ErrMissingServiceID' error
		getResult = List(returnVals...).Op(":=").Qual(g.base.APIPackage.PkgPath, i.method).Call(Qual(generators.FastlyPackagePath, "TestClient"), Lit(""))
		testResult = Err().Op("!=").Qual(generators.FastlyPackagePath, "ErrMissingServiceID")
		generateError = Id("t").Dot("Fatalf").Call(Lit("expected '%s', got: '%s'"), Qual(generators.FastlyPackagePath, "ErrMissingServiceID"), Err())

		body = append(body, If(getResult, testResult).Block(generateError))
	} else {
		// generate test cases based on the 'valid' slice in
		// the TestCases map in the template, which validate
		// that an empty 'serviceID' parameter produces an
		// 'ErrMissingServiceID' error; each case in the slice
		// must provide a valid input structure for the
		// function being validated, so that the only error
		// generated will be for the missing service ID
		getResult = List(returnVals...).Op(":=").Qual(g.base.APIPackage.PkgPath, i.method).Call(Qual(generators.FastlyPackagePath, "TestClient"), Lit(""), Op("&").Id("tc").Dot("Input"))
		testResult = Err().Op("!=").Qual(generators.FastlyPackagePath, "ErrMissingServiceID")
		generateError = Id("t").Dot("Fatalf").Call(Lit("expected '%s', got: '%s'"), Qual(generators.FastlyPackagePath, "ErrMissingServiceID"), Err())
		body = append(body, For(List(Id("_"), Id("tc")).Op(":=").Range().Id(i.testCaseMap).Index(Lit("valid"))).Block(If(getResult, testResult).Block(generateError)))

		// generate test cases based on the 'invalid' slice in
		// the TestCases map in the template, which produce
		// validation errors based on the specific needs of
		// the template; each case in the slice must provide an
		// invalid input structure for the function being
		// validated, and the error which should be expected
		// for that case. the 'serviceID' parameter to the
		// function will be populated so that the only error
		// generated will be the one generated by the case's
		// input structure.
		getResult = List(returnVals...).Op(":=").Qual(g.base.APIPackage.PkgPath, i.method).Call(Qual(generators.FastlyPackagePath, "TestClient"), Qual(generators.FastlyPackagePath, "TestDeliveryServiceID"), Op("&").Id("tc").Dot("Input"))
		testResult = Id("tc").Dot("WantError").Op("!=").Nil().Op("&&").Err().Op("!=").Id("tc").Dot("WantError")
		generateError = Id("t").Dot("Fatalf").Call(Lit("expected '%s', got: '%s'"), Id("tc").Dot("WantError"), Err())
		body = append(body, For(List(Id("_"), Id("tc")).Op(":=").Range().Id(i.testCaseMap).Index(Lit("invalid"))).Block(getResult, If(testResult).Block(generateError)))
	}

	i.f.Func().Id("Test_" + i.method + "_validation").Add(Params(parameter)).Block(body...)
	i.f.Line()
}

func validateGetFunction(g *Generator, f *File) {
	validateFunction(g, &validateFunctionInput{
		f:           f,
		method:      "Get",
		returnsBody: true,
	})
}

func validateEnableFunction(g *Generator, f *File, needsInput bool) {
	i := validateFunctionInput{
		f:           f,
		method:      "Enable",
		returnsBody: true,
		needsInput:  needsInput,
		testCaseMap: "EnableInputTestCases",
	}

	validateFunction(g, &i)
}

func validateDisableFunction(g *Generator, f *File) {
	validateFunction(g, &validateFunctionInput{
		f:      f,
		method: "Disable",
	})
}

func validateGetConfigurationFunction(g *Generator, f *File) {
	validateFunction(g, &validateFunctionInput{
		f:           f,
		method:      "GetConfiguration",
		returnsBody: true,
	})
}

func validateUpdateConfigurationFunction(g *Generator, f *File) {
	i := validateFunctionInput{
		f:           f,
		method:      "UpdateConfiguration",
		returnsBody: true,
		needsInput:  true,
		testCaseMap: "ConfigureInputTestCases",
	}

	validateFunction(g, &i)
}
